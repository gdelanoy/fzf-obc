#!/usr/bin/env bash


__fzf_add2compreply() {
  # Input: string separated by $'\0'
  if ! readarray -d $'\0' -O "${#COMPREPLY[@]}" COMPREPLY 2> /dev/null;then
    while IFS=$'\0' read -r -d '' line;do COMPREPLY+=( "${line}" );done
  fi
}

__fzf_compreply() {
  # Input: string separated by $'\0'
  if ! readarray -d $'\0' COMPREPLY 2> /dev/null;then
    IFS=$'\0' read -r -d '' -a COMPREPLY
  fi
}

__fzf_obc_sort_cmd() {
  # sort cmd used to show results
  (LC_ALL=C sort -ufrz -S 50% --parallel="$( awk '/^processor/{print $3}' < /proc/cpuinfo | wc -l)" 2> /dev/null || LC_ALL=C sort -ufrz)
}

__fzf_obc_colorized() {
  local IFS=' '
  local ls_colors_arr
  IFS=':' read -r -a ls_colors_arr <<< "${LS_COLORS}"
  declare -A fzf_obc_colors
  local arg
  local r
  for arg in "${ls_colors_arr[@]}";do
    IFS='=' read -r -a r <<< "${arg}"
    if [[ "${r[0]}" == "*"* ]];then
      fzf_obc_colors[ext_${r[0]/\*\.}]="${r[1]}"
    else
      fzf_obc_colors[type_${r[0]}]="${r[1]}"
    fi
  done

  while IFS=$'\0' read -r -d '' -t 0.1 line;do
    type="${line:0:2}"
    file="${line:3}"
    if [[ "${type}" == "fi"  ]];then
      ext="${file##*.}"
      printf "\e[${fzf_obc_colors[ext_${ext}]:-0}m%s\e[0m\0" "$file"
    else
      printf "\e[${fzf_obc_colors[type_${type}]:-0}m%s\e[0m\0" "$file"
    fi
  done
}

# get find exclude pattern
__fzf_obc_globs_exclude() {
  local var=$1
  local sep str fzf_obc_globs_exclude_array
  IFS=':' read -r -a fzf_obc_globs_exclude_array <<< "${FZF_OBC_EXCLUDE_PATH}"
  if [[ ${#fzf_obc_globs_exclude_array[@]} -ne 0 ]];then
    str="\( -path '*/${fzf_obc_globs_exclude_array[0]%/}"
    for pattern in "${fzf_obc_globs_exclude_array[@]:1}";do
      __fzf_obc_expand_tilde_by_ref pattern
      if [[ "${pattern}" =~ ^/ ]];then
        sep="' -o -path '"
      else
        sep="' -o -path '*/"
      fi
      pattern=${pattern%\/}
      str+=$(printf "%s" "${pattern/#/$sep}")
    done
    str+="' \) -prune -o"
  fi
  eval "${var}=\"${str}\""
}


# To use custom commands instead of find, override __fzf_obc_search later
# Return: list of files/directories separated by $'\0'
__fzf_obc_search() {
  local IFS=$'\n'
  local cur type xspec
  cur="${1}"
  type="${2}"
  xspec="${3}"

  local cur_clean
  cur_clean="${cur%%\**}"

  local cur_expanded
  cur_expanded=${cur_clean:-./}

  __fzf_obc_expand_tilde_by_ref cur_expanded

  local startdir
  if [[ "${cur_expanded}" != *"/" ]];then
    startdir="${cur_expanded}*"
    mindepth="0"
    maxdepth="0"
  else
    startdir="${cur_expanded}"
    mindepth="1"
    maxdepth="1"
  fi

  if [[ "${cur}" == *"**" ]];then
    maxdepth="${FZF_OBC_GLOBS_MAXDEPTH}"
    local exclude_string
    __fzf_obc_globs_exclude exclude_string
  fi

  local cmd
  cmd=""
  cmd="command find ${startdir}"
  cmd+=" -mindepth ${mindepth} -maxdepth ${maxdepth}"
  cmd+=" ${exclude_string}"
  if [[ "${type}" == "paths" ]] || [[ "${type}" == "dirs" ]];then
    cmd+=" -type d \( -perm -o=+t -a -perm -o=+w \) -printf 'tw %p/\0'"
    cmd+=" -or"
    cmd+=" -type d \( -perm -o=+w \) -printf 'ow %p/\0'"
    cmd+=" -or"
    cmd+=" -type d \( -perm -o=+t -a -perm -o=-w \) -printf 'st %p/\0'"
    cmd+=" -or"
    cmd+=" -type d -printf 'di %p/\0'"
  fi
  if [[ "${type}" == "paths" ]];then
    cmd+=" -or"
  fi
  if [[ "${type}" == "paths" ]] || [[ "${type}" == "files" ]];then
    cmd+=" -type b -printf 'bd %p\0'"
    cmd+=" -or"
    cmd+=" -type c -printf 'cd %p\0'"
    cmd+=" -or"
    cmd+=" -type p -printf 'pi %p\0'"
    cmd+=" -or"
    cmd+=" -type l -printf 'ln %p\0'"
    cmd+=" -or"
    cmd+=" -type s -printf 'so %p\0'"
    cmd+=" -or"
    cmd+=" -type f \( -perm -u=x -o -perm -g=x -o -perm -o=x \) -printf 'ex %p\0'"
    cmd+=" -or"
    cmd+=" -type f -printf 'fi %p\0'"
  fi

  cmd+=" 2> /dev/null"

  if [[ "${cur_expanded}" != "${cur_clean}" ]];then
    cmd=" sed -z s'#${cur_expanded//\//\\/}#${cur_clean//\//\\/}#' < <(${cmd})"
  fi

  if [[ -n ${xspec} ]];then
    cmd=" __fzf_obc_search_filter_bash '${xspec}' < <(${cmd})"
  fi

  if [[ "${FZF_OBC_COLORS}" == "1" ]] && [[ "${#LS_COLORS[@]}" -gt 0 ]];then
    cmd="__fzf_obc_colorized < <(${cmd})"
  else
    cmd="awk 'BEGIN{ RS=\"\0\";IFS=\" \" }{\$1=\"\"; printf(\"%s\0\",substr(\$0,2)) }' < <(${cmd})"
  fi

  eval "${cmd}"
  return 0
}

__fzf_obc_search_filter_bash() (
  # Input: a list of strings separated by $'\0'
  # Params:
  #   $1: an optional glob patern for filtering
  # Return: a list of strings filtered and separate by $'\0'
  shopt -s extglob
  local xspec="$1"
  [[ -z "${xspec}" ]] && cat
  while IFS= read -t 0.1 -d $'\0' -r file;do
    [[ "${file}" == ${xspec} ]] && printf "%s\0" "${file}"
  done
)

__fzf_obc_expand_tilde_by_ref ()
{
  local expand
  # Copy from original bash complete
  if [[ ${!1} == \~* ]]; then
    read -r -d '' expand < <(printf ~%q "${!1#\~}")
    eval "$1"="${expand}";
  fi
}

__fzf_obc_tilde ()
{
  # Copy from original bash complete
  local result=0;
  if [[ $1 == \~* && $1 != */* ]]; then
      COMPREPLY=($( compgen -P '~' -u -- "${1#\~}" ));
      result=${#COMPREPLY[@]};
      [[ $result -gt 0 ]] && compopt -o filenames 2> /dev/null;
  fi;
  return "${result}"
}

__fzf_obc_cmd() {
    fzf --read0 --print0 --ansi
}

__fzf_obc_read_compreply() {
  local IFS=$'\n'
  if [[ "${#COMPREPLY[@]}" -ne 0 ]];then
    if [[ "${cur}" == *"**" ]];then
      local item
      compopt +o filenames
      __fzf_compreply < <(
        printf "%s\0" "${COMPREPLY[@]}" \
        | __fzf_obc_sort_cmd \
        | FZF_DEFAULT_OPTS="--reverse --height ${FZF_OBC_HEIGHT} ${FZF_OBC_GLOBS_OPTS} ${FZF_OBC_GLOBS_BINDINGS}" \
          __fzf_obc_cmd \
        | while IFS= read -d $'\0' -r item;do printf "%q " "${item}" | sed 's/^\\~/~/';done \
        | sed 's/ $//'
      )
    else
      __fzf_compreply < <(
        printf "%s\0" "${COMPREPLY[@]}" \
        | __fzf_obc_sort_cmd \
        | FZF_DEFAULT_OPTS="--reverse --height ${FZF_OBC_HEIGHT} ${FZF_OBC_OPTS} ${FZF_OBC_BINDINGS}" \
          __fzf_obc_cmd \
        | sed 's#/\x0#\x0#'
      )
    fi
    printf '\e[5n'
  else
    if [[ "${cur}" == *"**" ]];then
      compopt -o nospace
      COMPREPLY=( "${cur%\*\*}" )
    fi
  fi
}

